#!/usr/bin/env node
'use strict';

const Profile = require('../dist/index.cjs');
const program = require('commander');
const chalk = require('chalk');
const fs = require('fs');
const path = require('path');
const SilentError = require('silent-error');
const d3 = require('d3');

function methodNames(val) {
  return val.split(',');
}

program
  .option('-f, --file <file>', 'Path to trace json file')
  .option('-m, --methods <names|file>', 'List of methods to aggregate', methodNames)
  .option('-r, --report <heuristicDir>', 'Generates a report with aggregated sums for each heuristic category and aggregated sum across all heuristics')
  .parse(process.argv);

const error = chalk.bold.red;

let { file, methods, report } = program;
const defaultProfilePath = `${process.cwd()}/profile.json`;
const defaultMethodsPath = `${process.cwd()}/.methods.json}`;

if (file === undefined && fs.existsSync(defaultProfilePath) === false) {
  throw new SilentError(error(`Error: Must pass a path to the trace file ðŸ’£`));
}

let categories;

if (report) {
  let files = fs.readdirSync(report);
  categories = {};
  files.map(file => {
    let name = path.basename(file).replace('.json', '');
    let methods = JSON.parse(fs.readFileSync(`${report}/${file}`));
    categories[name] = methods;
  });
} else {

  if (methods === undefined && fs.existsSync(defaultMethodsPath) === false) {
    throw new SilentError(error(`Error: Must pass a list of method names or have a ".methods.json" file at the root of the project.`));
  }

  if (methods === undefined) {
    methods = JSON.parse(fs.readFileSync(defaultMethodsPath, 'utf8'));
  } else if (methods && fs.existsSync(process.cwd() + '/' + methods)) {
    methods = JSON.parse(fs.readFileSync(process.cwd() + '/' + methods, 'utf8'));
  }
}

const filePath = file || defaultProfilePath;
const traceEvents = JSON.parse(fs.readFileSync(filePath, 'utf8'));
const trace = Profile.loadTrace(traceEvents);
const profile = trace.cpuProfile;

const root = d3.hierarchy(profile.root, (node) => {
  if (node.children) {
    return node.children.map((id) => profile.nodes.get(id)).filter(node => node.callFrame.functionName !== '(idle)' && node.callFrame.functionName !== '(program)' && node.callFrame.functionName !== '(garbage collector)')
  }
}).sum(d => d.hitCount).sort((a, b) => {
  return b.value - a.value;
});

class Aggregator {
  constructor(profile, root) {
    this.root = root;
    this.profile = profile;
    this.methods = undefined;
  }

  _sumsPerMethod(methodName) {
    let sum = 0;
    this.root.each(node => {
      if (node.data.callFrame.functionName === methodName) {
        sum += node.data.hitCount;
        if (node.children) {
          sum += this._aggregateChildren(node)
        }
      }
    });

    return sum;
  }

  _aggregateChildren(node) {
    let sum = 0;

    const aggregate = (node) => {
      node.children.forEach((n) => {
        if (!this.methods.includes(n.data.callFrame.functionName)) {
          sum += n.data.hitCount;
          if (n.children) {
            aggregate(n);
          }
        }
      });
    }

    aggregate(node);
    return sum;
  }

  sumsPerHeuristicCategory(methods) {
    let { profile } = this;
    this.methods = methods;
    let sums = {};
    methods.forEach(method => {
      sums[method] = toMS(this._sumsPerMethod(method), profile.hitCount, profile.duration);
    });
    this.methods = undefined;

    let total = Object.keys(sums).reduce((accumulator, current) => {
      return accumulator += sums[current];
    }, 0);

    return { sums, total };
  }

  sumsAllHeuristicCategories(categories) {
    let _categories = Object.keys(categories);
    let all = {
      categorized: {},
      all: {}
    }

    let allMethods = [];

    _categories.forEach((category) => {
      let methods = categories[category];
      allMethods.push(...methods);
      all.categorized[category] = this.sumsPerHeuristicCategory(methods);
    });

    this.methods = allMethods;
    all.all = this.sumsPerHeuristicCategory(allMethods);
    this.methods = undefined;
    return all;
  }
}

class Reporter {
  constructor(aggregator) {
    this.aggregator = aggregator;
  }

  categoryReport(methods) {
    let result = this.aggregator.sumsPerHeuristicCategory(methods);
    this.print(`Aggregated Sum:`, result);
  }

  fullReport(categories) {
    let { categorized, all } = this.aggregator.sumsAllHeuristicCategories(categories);
    Object.keys(categorized).forEach((category) => {
      this.print(`Aggregated Sum For ${category}:`, categorized[category]);
    });
    this.print(`Total Aggregated Sum:`, all);
  }

  print(title, body) {
    let buffer = chalk.bold.white(`\n${title}\n================\n`);
    Object.keys(body.sums).forEach((methodName) => {
      buffer += `${chalk.bold.magenta(methodName)}: ${round(body.sums[methodName])}ms\n`
    });
    buffer += chalk.bold.white(`================\nTotal: ${round(body.total)}ms`);
    console.log(buffer);
  }
}

function round(num) {
  return Math.round(num * 100) / 100;
}

function toMS(num, freq, dur) {
  return ((num / freq) * dur) / 1000;
}

let aggregator = new Aggregator(profile, root);
let reporter = new Reporter(aggregator);

if (program.report) {
  reporter.fullReport(categories);
} else {
  reporter.categoryReport(methods);
}
